# 2024 年 11 月学习日志

> 本文件从原 `README.md` 中拆分而来，记录 11 月的阶段性进展。

## 目录
- [11.7](#117)
- [11.8](#118)
- [11.10](#1110)
- [11.15](#1115)
- [11.16](#1116)

### 11.7 {#117}
- 建造仓库：[Hypervisor-in-1k-lines](https://github.com/manchangfengxu/Hypervisor-in-1k-lines)

### 11.8 {#118}
- 完成初次riscv虚拟化进入
``` rust
    unsafe {
        asm!(
            "csrw hstatus, {hstatus}",
            "csrw sepc, {sepc}",
            "sret",
            hstatus = in(reg) hstatus,
            sepc = in(reg) sepc,
        );
    }
```

### 11.10 {#1110}
- 设置二级映射，hgatp
- 填充bin文件，映射sept = guest_entry, 并在sret时成功进入
``` rust
    unsafe {
        asm!(
            "csrw hstatus, {hstatus}",
            "csrw hgatp, {hgatp}",
            "csrw sepc, {sepc}",
            "sret",
            hstatus = in(reg) hstatus,
            hgatp = in(reg) table.hgatp(),
            sepc = in(reg) sepc,
        );
    }
```
```
(qemu) info registers

CPU#0
 V      =   1
 pc       0000000000100000
 mhartid  0000000000000000
 mstatus  0000000a00000080
 hstatus  0000000200000000
 vsstatus 0000000a00000000
......
```

### 11.15 {#1115}
完成了初次的hypercall调用，进行了打印.这里`trap_handler`处理的逻辑和os很像
- `sscratch`来保存`vcpu`指针,交换到`a0`通过offest保存上下文到vcpu字段
``` s
trap_handler:
    # Swap a0 and sscratch.
    csrrw a0, sscratch, a0

    # a0 is now a pointer to a VCpu. Save registers except a0.
    sd ra, {ra_offset}(a0)
    sd sp, {sp_offset}(a0)
    sd gp, {gp_offset}(a0)
    sd tp, {tp_offset}(a0)
    #......
```
- 进入`hs`后通过读取相关寄存器(csr,和通用寄存器)来处理
``` rust
extern "C" fn handle_trap(vcpu: *mut VCpu) -> ! {
    let vcpu = unsafe { &mut *vcpu };

    let scause = read_csr!("scause");
    let sepc = read_csr!("sepc");
    let stval = read_csr!("stval");

    let scause_str = match scause {
        10 => "Environment call from VS-mode",
        _ => "unknown trap",
    };

    if scause == 10 {
        println!(
            "SBI call: eid={:#x}, fid={:#x}, a0={:#x} ('{}')",
            vcpu.a7,
            vcpu.a6,
            vcpu.a0,
            vcpu.a0 as u8 as char,
        );
        // Resume the guest after the ECALL instruction.
        vcpu.sepc = sepc + 4;
    } else {
        panic!(
            "trap handler: {} at {:#x} (stval={:#x})",
            scause_str, sepc, stval,
        );
    }

    vcpu.run();
}
```

### 11.16 {#1116}
今天实现了`boot linux`,在vcpu_run后去启动linux
- 了解到了在不设置hedeleg时，` auipc   a0, 0x0 `探针产生的trap会委托到hs去处理,设置后交由vs处理,此时linux的`trap_handler`自动处理
``` rust
        let mut hedeleg: u64 = 0;
        hedeleg |= 1 << 0; // Instruction address misaligned
        hedeleg |= 1 << 1; // Instruction access fault
        hedeleg |= 1 << 2; // Illegal instruction
        hedeleg |= 1 << 3; // Breakpoint
        hedeleg |= 1 << 4; // Load address misaligned
        hedeleg |= 1 << 5; // Load access fault
        hedeleg |= 1 << 6; // Store/AMO address misaligned
        hedeleg |= 1 << 7; // Store/AMO access fault
        hedeleg |= 1 << 8; // Environment call from U-mode
        hedeleg |= 1 << 12; // Instruction page fault
        hedeleg |= 1 << 13; // Load page fault
        hedeleg |= 1 << 15; // Store/AMO page fault
```
- 约定中,`vcpu.a0`为 `hart ID`
